#!/usr/bin/env tsx

import { config } from "dotenv";
import path from "path";

// Load environment variables FIRST, before importing other modules
const envPath = path.resolve(process.cwd(), ".env.local");
config({ path: envPath });

// Now import other modules after environment variables are loaded
import connectToDatabase from "../lib/mongodb";
import Vocabulary from "../models/Vocabulary";
import Language from "../models/Language";
import Papa from "papaparse";
import fs from "fs";

interface CSVRow {
  word: string;
  translation: string;
  pronunciation: string;
  category?: string;
  example?: string;
  exampleTranslation?: string;
}

interface ImportOptions {
  filePath: string;
  languageCode: string;
  dryRun?: boolean;
  verbose?: boolean;
}

interface ProcessedVocabulary {
  word: string;
  translation: string;
  pronunciation: string;
  languageCode: string;
  category: string;
  example: string;
  exampleTranslation: string;
  isActive: boolean;
}

const handleImport = async (options: ImportOptions): Promise<void> => {
  const { filePath, languageCode, dryRun = false, verbose = false } = options;

  try {
    // Check if file exists
    if (!fs.existsSync(filePath)) {
      console.error(`‚ùå File not found: ${filePath}`);
      process.exit(1);
    }

    // Connect to database
    console.log("üîå Connecting to database...");
    await connectToDatabase();
    console.log("‚úÖ Database connected successfully");

    // Check if language exists, if not create it automatically
    let language = await Language.findOne({
      code: languageCode.toUpperCase(),
    });

    if (!language) {
      console.log(
        `üåç Language '${languageCode}' not found, creating automatically...`
      );

      // Language mapping for common languages
      const languageNames: { [key: string]: string } = {
        EN: "English",
        VI: "Vietnamese",
        FR: "French",
        DE: "German",
        ES: "Spanish",
        IT: "Italian",
        PT: "Portuguese",
        RU: "Russian",
        JA: "Japanese",
        KO: "Korean",
        ZH: "Chinese",
        AR: "Arabic",
        HI: "Hindi",
        TH: "Thai",
        NL: "Dutch",
        SV: "Swedish",
        NO: "Norwegian",
        DA: "Danish",
        FI: "Finnish",
        PL: "Polish",
        CS: "Czech",
        HU: "Hungarian",
        RO: "Romanian",
        BG: "Bulgarian",
        HR: "Croatian",
        SK: "Slovak",
        SL: "Slovenian",
        ET: "Estonian",
        LV: "Latvian",
        LT: "Lithuanian",
        MT: "Maltese",
        GA: "Irish",
        CY: "Welsh",
        EU: "Basque",
        CA: "Catalan",
        GL: "Galician",
        IS: "Icelandic",
        MK: "Macedonian",
        SQ: "Albanian",
        SR: "Serbian",
        BS: "Bosnian",
        ME: "Montenegrin",
        XK: "Kosovan",
      };

      // Flag emojis for each language
      const languageFlags: { [key: string]: string } = {
        EN: "üá∫üá∏",
        VI: "üáªüá≥",
        FR: "üá´üá∑",
        DE: "üá©üá™",
        ES: "üá™üá∏",
        IT: "üáÆüáπ",
        PT: "üáµüáπ",
        RU: "üá∑üá∫",
        JA: "üáØüáµ",
        KO: "üá∞üá∑",
        ZH: "üá®üá≥",
        AR: "üá∏üá¶",
        HI: "üáÆüá≥",
        TH: "üáπüá≠",
        NL: "üá≥üá±",
        SV: "üá∏üá™",
        NO: "üá≥üá¥",
        DA: "üá©üá∞",
        FI: "üá´üáÆ",
        PL: "üáµüá±",
        CS: "üá®üáø",
        HU: "üá≠üá∫",
        RO: "üá∑üá¥",
        BG: "üáßüá¨",
        HR: "üá≠üá∑",
        SK: "üá∏üá∞",
        SL: "üá∏üáÆ",
        ET: "üá™üá™",
        LV: "üá±üáª",
        LT: "üá±üáπ",
        MT: "üá≤üáπ",
        GA: "üáÆüá™",
        CY: "üá®üáæ",
        EU: "üá™üá∫",
        CA: "üá™üá∏",
        GL: "üá™üá∏",
        IS: "üáÆüá∏",
        MK: "üá≤üá∞",
        SQ: "üá¶üá±",
        SR: "üá∑üá∏",
        BS: "üáßüá¶",
        ME: "üá≤üá™",
        XK: "üáΩüá∞",
      };

      const languageName =
        languageNames[languageCode.toUpperCase()] || languageCode.toUpperCase();

      const languageFlag = languageFlags[languageCode.toUpperCase()] || "üåç";

      language = new Language({
        code: languageCode.toUpperCase(),
        name: languageName,
        flag: languageFlag,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      if (!dryRun) {
        await language.save();
        console.log(
          `‚úÖ Created new language: ${languageName} (${languageCode.toUpperCase()})`
        );
      } else {
        console.log(
          `üîç Would create new language: ${languageName} (${languageCode.toUpperCase()})`
        );
      }
    } else {
      console.log(
        `üìö Using existing language: ${language.name} (${language.code})`
      );
    }

    console.log(
      `üìö Importing vocabulary for language: ${language.name} (${language.code})`
    );

    // Read and parse CSV file
    console.log(`üìñ Reading CSV file: ${filePath}`);
    const csvContent = fs.readFileSync(filePath, "utf-8");
    const { data, errors } = Papa.parse(csvContent, {
      header: true,
      skipEmptyLines: true,
    });

    if (errors.length > 0) {
      console.error("‚ùå CSV parsing errors:");
      errors.forEach((error) =>
        console.error(`  - Row ${error.row}: ${error.message}`)
      );
      process.exit(1);
    }

    console.log(`üìä Found ${data.length} rows in CSV`);

    // Process data with strict type checking
    const vocabularyData: ProcessedVocabulary[] = (data as CSVRow[]).map((row, index) => {
      // Type-safe data processing
      const word = row.word?.trim();
      const translation = row.translation?.trim();
      const pronunciation = row.pronunciation?.trim();
      const category = row.category?.trim() || "General";
      const example = row.example?.trim() || "";
      const exampleTranslation = row.exampleTranslation?.trim() || "";

      return {
        word,
        translation,
        pronunciation,
        languageCode: languageCode.toUpperCase(),
        category,
        example,
        exampleTranslation,
        isActive: true,
      };
    });

    // Validate data with strict type checking
    const validData: ProcessedVocabulary[] = vocabularyData.filter((item, index) => {
      if (!item.word || !item.translation || !item.pronunciation) {
        if (verbose) {
          console.warn(
            `‚ö†Ô∏è  Row ${index + 2}: Missing required fields (word: ${
              item.word
            }, translation: ${item.translation}, pronunciation: ${
              item.pronunciation
            })`
          );
        }
        return false;
      }
      return true;
    });

    const invalidCount = vocabularyData.length - validData.length;
    if (invalidCount > 0) {
      console.warn(
        `‚ö†Ô∏è  ${invalidCount} rows skipped due to missing required fields`
      );
    }

    if (validData.length === 0) {
      console.error("‚ùå No valid vocabulary data found");
      process.exit(1);
    }

    console.log(
      `‚úÖ ${validData.length} valid vocabulary items ready for import`
    );

    if (dryRun) {
      console.log("\nüîç DRY RUN - No data will be imported");
      console.log("Sample data:");
      validData.slice(0, 3).forEach((item, index) => {
        console.log(
          `  ${index + 1}. ${item.word} ‚Üí ${item.translation} [${
            item.pronunciation
          }]`
        );
      });
      return;
    }

    // Check for duplicates
    const existingWords = await Vocabulary.find({
      word: { $in: validData.map((item) => item.word) },
      languageCode: languageCode.toUpperCase(),
    });

    if (existingWords.length > 0) {
      console.warn(
        `‚ö†Ô∏è  Found ${existingWords.length} existing words that will be skipped:`
      );
      existingWords.forEach((word) => console.log(`  - ${word.word}`));

      // Filter out existing words
      const newWords = validData.filter(
        (item) => !existingWords.some((existing) => existing.word === item.word)
      );

      if (newWords.length === 0) {
        console.log("‚úÖ All words already exist in database");
        return;
      }

      console.log(`üìù ${newWords.length} new words will be imported`);
      validData.splice(0, validData.length, ...newWords);
    }

    // Import data
    console.log("üöÄ Importing vocabulary...");
    const result = await Vocabulary.insertMany(validData);

    console.log(`‚úÖ Successfully imported ${result.length} vocabulary items`);
    console.log(`üìä Total processed: ${data.length}`);
    console.log(`‚úÖ Valid items: ${validData.length}`);
    console.log(`‚ùå Skipped: ${invalidCount}`);
    console.log(`üîÑ Language: ${language.name} (${language.code})`);
  } catch (error) {
    console.error("‚ùå Error during import:", error);
    process.exit(1);
  }
};

const showHelp = (): void => {
  console.log(`
üìö CSV Vocabulary Import Tool

Usage:
  npm run import-csv <file-path> <language-code> [options]

Arguments:
  file-path      Path to the CSV file
  language-code  Language code (e.g., EN, VI, FR, DE, ES, etc.)

Options:
  --dry-run      Show what would be imported without actually importing
  --verbose      Show detailed information about skipped rows
  --help         Show this help message

Examples:
  npm run import-csv data/english-vocab.csv EN
  npm run import-csv data/vietnamese-vocab.csv VI --dry-run
  npm run import-csv data/french-vocab.csv FR --verbose
  npm run import-csv data/german-vocab.csv DE

Features:
  üåç Languages are created automatically if they don't exist
  üö© Flag emojis are added automatically for each language
  üìù Supports 50+ language codes with automatic naming
  üîç Smart duplicate detection and validation
  üìä Detailed import reporting and statistics

CSV Format:
  word,translation,pronunciation,category,example,exampleTranslation
  hello,xin ch√†o,h…ôÀàlo ä,Greetings,Hello, how are you?,Xin ch√†o, b·∫°n kh·ªèe kh√¥ng?
  goodbye,t·∫°m bi·ªát,Àå…° ädÀàba…™,Greetings,Goodbye, see you later!,T·∫°m bi·ªát, h·∫πn g·∫∑p l·∫°i!

Required fields: word, translation, pronunciation
Optional fields: category, example, exampleTranslation

Supported Language Codes:
  EN üá∫üá∏ (English), VI üáªüá≥ (Vietnamese), FR üá´üá∑ (French), DE üá©üá™ (German)
  ES üá™üá∏ (Spanish), IT üáÆüáπ (Italian), PT üáµüáπ (Portuguese), RU üá∑üá∫ (Russian)
  JA üáØüáµ (Japanese), KO üá∞üá∑ (Korean), ZH üá®üá≥ (Chinese), AR üá∏üá¶ (Arabic)
  HI üáÆüá≥ (Hindi), TH üáπüá≠ (Thai), NL üá≥üá± (Dutch), SV üá∏üá™ (Swedish)
  And many more with automatic flag emojis!
`);
};

const main = async (): Promise<void> => {
  const args = process.argv.slice(2);

  if (args.includes("--help") || args.includes("-h")) {
    showHelp();
    return;
  }

  if (args.length < 2) {
    console.error("‚ùå Missing required arguments");
    showHelp();
    process.exit(1);
  }

  const [filePath, languageCode] = args;
  const dryRun = args.includes("--dry-run");
  const verbose = args.includes("--verbose");

  await handleImport({
    filePath,
    languageCode,
    dryRun,
    verbose,
  });
};

// Run if called directly
if (require.main === module) {
  main().catch((error) => {
    console.error("‚ùå Fatal error:", error);
    process.exit(1);
  });
}
